Pretty
======

In addition to syntax highlighting, Rich will format (i.e. *pretty print*) any containers (lists, dicts, sets etc) you print to the console.

Run the following command to see an example of pretty printed output::

    python -m rich.pretty

Note how the output is formatted to fit within the width of the terminal.

pprint method
-------------

The :func:`~rich.pretty.pprint` method offers a few more argument you can use to tweak how objects are pretty printed. Here's how you would import it::

    >>> from rich.pretty import pprint
    >>> pprint(locals())

Indent guides
~~~~~~~~~~~~~

Rich can draw *intent guides* to highlight the indent level of a data structure. These can make it easier to read more deeply nested output. The pprint method enables indent guides by default, but you can set ``indent_guides=False`` to disable this feature. 

Expand all
~~~~~~~~~~

Rich is quite conservative about expanding data structures and will try to fit as much in each line as it can. If you prefer, you can tell Rich to fully expand all data structures by setting ``expand_all=True``. Here's an example::

    >>> pprint(["eggs", "ham"], expand_all=True)

Truncating pretty output
~~~~~~~~~~~~~~~~~~~~~~~~

Very long data structures can be difficult to read and you may find yourself scrolling through multiple pages to find the output you are interested in. Rich can truncate containers and long strings if you just need a general overview a data structure.

If you set the ``max_length`` argument to an integer then Rich will truncate containers with more than the given number of elements. If data is truncated, Rich will display an ellipsis ``...`` and the number of elements not shown.

Here's an example::

    >>> pprint(locals(), max_length=2)

Truncating long strings
~~~~~~~~~~~~~~~~~~~~~~~

If you set the `max_string` argument to an integer, Rich will truncate strings over that length. Truncated string will be appended with the number of characters that have not been shown. Here's an example::

    >>> pprint("Where there is a Will, there is a Way", max_string=21)

Pretty renderable
-----------------

Rich offers a :class:`~rich.pretty.Pretty` class which you can user to insert pretty printed data in to another renderable.

The following example, prints pretty printed output within a simple panel::

    from rich import print
    from rich.pretty import Pretty
    from rich.panel import Panel

    pretty = Pretty(locals())
    panel = Panel(pretty)
    print(panel)

There are a large number of options to tweak the pretty formatting, See the :class:`~rich.pretty.Pretty` reference for details.

Rich Repr
---------

Rich is able to syntax highlight any output, but the extra formatting done by the pretty printing is restricted to builtin containers, dataclasses, and other objects Rich knows about, such as objects generated by the `attrs <https://www.attrs.org/en/stable/>`_ library. Fortunately Rich offers a simple protocol you can use to add pretty printable output to any object.

First, let's look at a class that might benefit from a Rich repr::

    class Bird:
        def __init__(self, name, eats=None, fly=True, extinct=False):
            self.name = name
            self.eats = list(eats) if eats else []
            self.fly = fly
            self.extinct = extinct

        def __repr__(self):
            return f"Bird({self.name!r}, eats={self.eats!r}, fly={self.fly!r}, extinct={self.extinct!r})"

    BIRDS = {
        "gull": Bird("gull", eats=["fish", "chips", "ice cream", "sausage rolls"]),
        "penguin": Bird("penguin", eats=["fish"], fly=False),
        "dodo": Bird("dodo", eats=["fruit"], fly=False, extinct=True)
    }
    print(BIRDS)

The result of this script would be::

    {'gull': Bird('gull', eats=['fish', 'chips', 'ice cream', 'sausage rolls'], fly=True, extinct=False), 'penguin': Bird('penguin', eats=['fish'], fly=False, extinct=False), 'dodo': Bird('dodo', eats=['fruit'], fly=False, extinct=True)}

The output is long enough to wrap on to the next line, which can make it hard to read. The repr strings are informative but a little verbose since they include default arguments. If we print this with Rich, things are improved somewhat::

    {
        'gull': Bird('gull', eats=['fish', 'chips', 'ice cream', 'sausage rolls'],
    fly=True, extinct=False),
        'penguin': Bird('penguin', eats=['fish'], fly=False, extinct=False),
        'dodo': Bird('dodo', eats=['fruit'], fly=False, extinct=True)
    }

Rich knows how to format the container dict, but the repr strings are still verbose, and there is some wrapping of the output (assuming an 80 character terminal).

We can solve both these issues by adding the following ``__rich_repr__`` method::

    def __rich_repr__(self):
        yield self.name
        yield "eats", self.eats
        yield "fly", self.fly, True
        yield "extinct", self.extinct, False

Now if we print the same object with Rich we would get the following::

    {
        'gull': Bird(
            'gull',
            eats=['fish', 'chips', 'ice cream', 'sausage rolls']
        ),
        'penguin': Bird('penguin', eats=['fish'], fly=False),
        'dodo': Bird('dodo', eats=['fruit'], fly=False, extinct=True)
    }

The default arguments have been omitted, and the output has been formatted nicely. Even if we have less room in the terminal, the result is still quite readable::

    {
        'gull': Bird(
            'gull',
            eats=[
                'fish',
                'chips',
                'ice cream',
                'sausage rolls'
            ]
        ),
        'penguin': Bird(
            'penguin',
            eats=['fish'],
            fly=False
        ),
        'dodo': Bird(
            'dodo',
            eats=['fruit'],
            fly=False,
            extinct=True
        )
    }

You can add a ``__rich_repr__`` method to any class to enable Rich reprs. This method should return an iterable of tuples. You could return a list of tuples, but it's easier to express with the ``yield`` keywords, making it a *generator*.

Each tuple specifies an element in the output.

- ``yield value`` will generate a positional argument.
- ``yield name, value`` will generate a keyword argument.
- ``yield name, value, default`` will generate a keyword argument *if* ``value`` is not equal to ``default``. 

You can also tell Rich to generate the *angular bracket* style of repr, which tend to be used where there is no easy way to recreate the object's constructor. To do this set the function attribute ``"angluar"`` to ``True`` immediately after your ``__rich_repr__`` methods. For example::

    __rich_repr__.angular = True

Note that you can add ``__rich_repr__`` methods to third-party libraries *without* including Rich as a dependency. If Rich is not installed, then nothing will break. Hopefully many more libraries will adopt Rich repr methods in the future, which will aid debugging!